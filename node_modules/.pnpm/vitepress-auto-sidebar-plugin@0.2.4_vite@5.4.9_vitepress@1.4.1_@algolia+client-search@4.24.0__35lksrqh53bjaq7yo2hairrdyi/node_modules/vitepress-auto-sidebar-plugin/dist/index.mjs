import { basename, normalize, resolve, sep, join, extname } from 'pathe';
import glob from 'fast-glob';
import { debounce } from 'perfect-debounce';
import { consola } from 'consola';
import { readFileSync } from 'node:fs';
import matter from 'gray-matter';

const log = consola;

function getArticleData(path) {
  const file = readFileSync(path, "utf-8");
  const { content, data } = matter(file);
  const h1 = getArticleTitle(content) || "";
  const index = data.index || getPathIndex(path);
  return {
    ...data,
    h1,
    index
  };
}
function getArticleTitle(content) {
  const match = content.match(/^#\s*(.+)/m);
  return match?.[1].trim();
}
function getPathIndex(path) {
  const name = basename(path);
  const match = name.match(/^(\d+)\./);
  let num;
  if (match)
    num = Number(match[1]);
  return num;
}
function useTextFormat(text, mode) {
  if (typeof mode === "function")
    return mode(text);
  switch (mode) {
    case "lowercase":
      return text.toLowerCase();
    case "uppercase":
      return text.toUpperCase();
    case "capitalize":
      return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
    case "kebabcase":
      return text.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
    case "titlecase":
      return text.split(/[ -]/).map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
    default:
      return text;
  }
}
function useSortIndexName(list) {
  return list.sort((a, b) => {
    if (a.includes("index.md") && !b.includes("index.md"))
      return -1;
    if (!a.includes("index.md") && b.includes("index.md"))
      return 1;
    return 0;
  });
}
function useIndexSort(list) {
  return list.sort((a, b) => {
    if (a.index === void 0 && b.index === void 0)
      return 0;
    else if (a.index === void 0)
      return 1;
    else if (b.index === void 0)
      return -1;
    else
      return a.index - b.index;
  });
}
function usePrevNextSort(list) {
  const insertList = list.filter((item) => item.sortPrev || item.sortNext);
  const listWithoutInsert = list.filter((item) => !item.sortPrev && !item.sortNext);
  insertList.forEach((item) => {
    if (item.sortPrev) {
      const index = listWithoutInsert.findIndex(({ name }) => name === item.sortPrev);
      listWithoutInsert.splice(index, 0, item);
    } else if (item.sortNext) {
      const index = listWithoutInsert.findIndex(({ name }) => name === item.sortNext);
      listWithoutInsert.splice(index + 1, 0, item);
    }
  });
  return listWithoutInsert;
}

function autoSidebarPlugin(options = {}) {
  let cwd = "./";
  const cache = {};
  const defaultOptions = {
    useH1Title: true
  };
  return {
    name: "vitepress-auto-sidebar-plugin",
    config: async (config) => {
      log.start("The Auto Sidebar is being generated...");
      const { vitepress: { userConfig } } = config;
      cwd = options.srcDir || userConfig.srcDir || "./";
      const pattern = options.pattern || "**.md";
      const ignoreList = options.ignoreList || userConfig.srcExclude || [];
      const paths = (await glob(pattern, {
        cwd,
        ignore: [
          "**/node_modules/**",
          "**/dist/**",
          "index.md",
          ...ignoreList
        ]
      })).map((path) => normalize(path));
      const list = setDataFormat(cwd, paths, { ...defaultOptions, ...options }, cache);
      const sidebar = generateSidebar(list);
      config.vitepress.site.themeConfig.sidebar = sidebar;
      log.success("The Auto Sidebar has been generated successfully!");
      return config;
    },
    configureServer({
      watcher,
      restart
    }) {
      watcher.add("*.md").on("all", debounce(async (type, path) => {
        if (type === "change") {
          const url = resolve(cwd) + sep;
          const link = path.split(url).pop();
          const obj = cache[link];
          const data = getArticleData(path);
          if (obj && JSON.stringify(obj) === JSON.stringify(data))
            return;
        }
        try {
          await restart();
          log.info("Update the sidebar...");
        } catch {
          log.error("Failed to update sidebar");
        }
      }, 800));
    }
  };
}
function setItem(cwd, list, options, cache = {}, link = "") {
  if (!list.length)
    return void 0;
  let name = list.shift();
  link = join(link, name);
  const isFile = !list.length && Boolean(extname(name));
  let text = name;
  let index = getPathIndex(link);
  let fileOptions = {};
  if (isFile) {
    name = name.replace(extname(name), "");
    fileOptions = getArticleData(resolve(cwd, link));
    cache[link] = fileOptions;
    text = fileOptions.title || (options.useH1Title ? fileOptions.h1 : name) || name;
  } else {
    if (options?.title?.map)
      text = options.title.map[`${link}/`] || text;
    else
      text = useTextFormat(text, options?.title?.mode || "titlecase");
  }
  const children = [setItem(cwd, list, options, cache, link)].filter(Boolean);
  let groupConfig = {};
  if (!isFile) {
    const { group, groupTitle, groupIndex, groupAlone, collapsed } = children.find((item) => item.name === "index") || {};
    if (groupTitle)
      text = groupTitle;
    if (groupIndex)
      index = groupIndex;
    groupConfig = {
      group: groupAlone || group,
      // 独立分组 group 必须为 true
      groupAlone,
      // 设置分组是否独立
      collapsed
      // 设置折叠分组配置，默认不开启，单独设置后开启
    };
  }
  return {
    index,
    name,
    text,
    link,
    isFile,
    children,
    ...groupConfig,
    ...fileOptions
  };
}
function setDataFormat(cwd, paths, {
  sort = () => 0,
  ...options
}, cache = {}) {
  let root = [];
  const list = useSortIndexName(paths);
  list.forEach((path) => {
    const list2 = path.split(sep);
    const obj = setItem(cwd, list2, options, cache);
    root = deep(root, obj, root);
  });
  function deep(list2, obj, root2) {
    const node = [...list2, ...root2].find((node2) => node2.name === obj.name);
    if (node) {
      obj.children.forEach((child) => {
        node.children = deep(node.children, child, root2);
      });
    } else {
      if (obj.group && !obj.isFile)
        root2.push(obj);
      else
        list2.push(obj);
    }
    list2 = useIndexSort(list2);
    list2 = usePrevNextSort(list2);
    return list2.sort(sort);
  }
  return root;
}
function generateSidebar(list) {
  const root = list.reduce((acc, { text, link, children, collapsed, groupAlone }) => {
    const items = deep(children).filter(Boolean);
    const obj = {
      text,
      items,
      collapsed
    };
    const key = `/${groupAlone ? link : link.split(sep)[0] || link}/`;
    if (!acc[key])
      acc[key] = [];
    acc[key].push(obj);
    return acc;
  }, {});
  function deep(list2) {
    return list2.map(({ text, link, isFile, children, hide, collapsed }) => {
      if (hide)
        return null;
      if (isFile) {
        return {
          text,
          link: `/${link}`
        };
      } else {
        return {
          text,
          collapsed,
          items: deep(children).filter(Boolean)
        };
      }
    });
  }
  return root;
}

export { autoSidebarPlugin as default, generateSidebar, setDataFormat, setItem };
